---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';

// 合作伙伴/赞助商数据
const partners = ["Google", "PlayStation", "Astro", "Apple", "GitHub", "Vercel", "Intel", "Adobe", "Figma"];
---

<Layout title="CREPUS VILLA | 首页">
    <Header />
    
    <main class="main-content">
        <div class="scrolling-text" id="scrollText">CREPUS VILLA</div>

        <section class="content-section reveal">
            <div class="container">
                <h1 class="hero-title">
                    创意，<span id="typewriter" class="accent-text"></span><span class="cursor"></span>
                </h1>
                <p class="sub-text">在这里，探索数字世界的无限可能。</p>
            </div>
        </section>

        <section class="horizontal-scroll-section" id="horizontalWrapper">
            <div class="sticky-container">
                <div class="horizontal-content" id="horizontalContent">
                    <div class="partner-intro">
                        <h2 class="partner-title">PARTNERS<br/>& SPONSORS</h2>
                        <p>协作共赢，<br/>定义未来。</p>
                    </div>
                    {partners.map(p => (
                        <div class="logo-card">
                            <span class="logo-name">{p}</span>
                        </div>
                    ))}
                </div>
            </div>
        </section>

        <section class="content-section">
            <div class="container text-center">
                <p class="huge-text">追求极致，<br/>不留余力。</p>
            </div>
        </section>
    </main>
</Layout>

<style>
    /* 4. 颜色与基础样式 */
    .accent-text {
        color: #f7c46c; /* 替换为你的新审美颜色 */
        /* 移除渐变，使用纯色更加高端 */
    }

    .main-content {
        background-color: #f5f5f7;
    }

    .scrolling-text {
        position: fixed;
        top: 25%;
        left: 0;
        font-size: 20vw;
        font-weight: 900;
        color: rgba(247, 196, 108, 0.08); /* 使用强调色的极淡透明版 */
        white-space: nowrap;
        pointer-events: none;
        z-index: 0;
        line-height: 1;
    }

    .container {
        position: relative;
        z-index: 1;
        max-width: 1100px;
        margin: 0 auto;
        padding: 0 40px;
    }

    /* 2. 横向滚动核心 CSS */
    .horizontal-scroll-section {
        position: relative;
        height: 300vh; /* 这里的倍数决定了滚动的时长感 */
        background: transparent;
    }

    .sticky-container {
        position: sticky;
        top: 0;
        height: 100vh;
        display: flex;
        align-items: center;
        overflow: hidden; /* 隐藏溢出内容 */
    }

    .horizontal-content {
        display: flex;
        padding: 0 10vw;
        will-change: transform;
        gap: 80px;
        align-items: center;
    }

    .partner-intro {
        min-width: 400px;
    }

    .partner-title {
        font-size: clamp(32px, 5vw, 64px);
        font-weight: 800;
        line-height: 1;
        color: var(--text-main);
    }

    .logo-card {
        min-width: 300px;
        height: 200px;
        background: rgba(255, 255, 255, 0.5);
        border: 1px solid rgba(0,0,0,0.03);
        border-radius: 24px;
        display: flex;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(5px);
    }

    .logo-name {
        font-size: 32px;
        font-weight: 600;
        color: #86868b;
    }

    /* 其余样式保持简约 */
    .content-section { min-height: 100vh; display: flex; align-items: center; }
    .hero-title { font-size: clamp(40px, 8vw, 90px); font-weight: 800; }
    .cursor { display: inline-block; width: 3px; height: 0.8em; background: #f7c46c; margin-left: 4px; animation: blink 1s step-end infinite; }
    @keyframes blink { 50% { background: transparent; } }
    
    .reveal { opacity: 0; transform: translateY(30px); transition: all 1s ease-out; }
    .reveal.active { opacity: 1; transform: translateY(0); }
</style>

<script>
    // 1. 打字机逻辑
    const words = ["由此开始。", "由你定义。", "永不止步。"];
    let wordIndex = 0, charIndex = 0, isDeleting = false;
    
    function type() {
        const target = document.getElementById('typewriter');
        if (!target) return;
        const currentWord = words[wordIndex];
        if (isDeleting) charIndex--; else charIndex++;
        target.textContent = currentWord.substring(0, charIndex);
        let delta = isDeleting ? 80 : 150;
        if (!isDeleting && charIndex === currentWord.length) { delta = 2000; isDeleting = true; }
        else if (isDeleting && charIndex === 0) { isDeleting = false; wordIndex = (wordIndex + 1) % words.length; delta = 500; }
        setTimeout(type, delta);
    }

    // 2. 滚动动效逻辑 (包含背景大字和横向滚动)
    const horizontalWrapper = document.getElementById('horizontalWrapper');
    const horizontalContent = document.getElementById('horizontalContent');
    const scrollText = document.getElementById('scrollText');

    window.addEventListener('scroll', () => {
        const scrolled = window.scrollY;

        // 背景文字平移
        if (scrollText) {
            scrollText.style.transform = `translateX(-${scrolled * 0.3}px)`;
        }

        // 横向滚动逻辑
        if (horizontalWrapper && horizontalContent) {
            const wrapperTop = horizontalWrapper.offsetTop;
            const wrapperHeight = horizontalWrapper.offsetHeight;
            const windowHeight = window.innerHeight;

            // 计算进入该区域后的百分比
            if (scrolled >= wrapperTop && scrolled <= (wrapperTop + wrapperHeight - windowHeight)) {
                const offset = scrolled - wrapperTop;
                const maxScroll = horizontalContent.scrollWidth - window.innerWidth;
                const scrollPercentage = offset / (wrapperHeight - windowHeight);
                
                // 将纵向滚动距离映射到横向偏移
                horizontalContent.style.transform = `translateX(-${scrollPercentage * maxScroll}px)`;
            }
        }
    });

    // 3. 入场观察
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) entry.target.classList.add('active');
        });
    }, { threshold: 0.1 });

    document.addEventListener('DOMContentLoaded', () => {
        type();
        document.querySelectorAll('.reveal').forEach(el => observer.observe(el));
    });
</script>